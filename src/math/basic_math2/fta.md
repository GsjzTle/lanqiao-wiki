---
title: 唯一分解定理
icon: circle-info
pageInfo: [ReadingTime, Word]
---



## 唯一分解定理

::: info 简介

对于一个大于 $1$ 的整数 $n$，它要么本身是个质数，要么可以被唯一地分解成若干质因子的乘积的形式（质因子是以指数形式出现，且按照质因子从小到大的顺序排列）。

:::

我们可以用数学公式将定理表示出来，即：
$$
n=
\prod_{i=1}^{k} p_{i}^{a_{i}}=p_{1}^{a_{1}} \times p_{2}^{a_{2}}\times \cdots \times p_{k}^{a_{k}}
$$
其中 $p_1, p_2, \ldots, p_k$ 为互不相同的质数，$a_1, a_2, \ldots, a_k$ 为正整数。

例如 $18$ 就可以表示为 $2^13^2$，它的质因子有 $2$、$3$，质因子 $2$ 的个数为 $1$（指数为 $1$），质因子 $3$ 的个数为 $2$（质数为 $2$）：
$$
p_1=2,a_1=1\\
p_2=3,a_2=2
$$
对于一个整数 $n$，它只有一种质因数分解的方式，不能有其他的分解方式。

例如 $18$ 它只有 $2^1 3^2$ 这一种质因数分解的方式，而不能有其他的分解方式，如：
$$
18 \neq 2^2 3^1 \\
18 \neq 2^1 3^3 \\
\cdots
$$
唯一分解定理的应用非常广泛，下面我们来看看常见的三种应用。

### 一、质因数分解

---

+ 唯一分解定理 + 试除法。

质因数分解是将一个正整数分解成若干个**质因子**的乘积，它和`因数分解`类似，通过枚举 $[2,\sqrt{n}]$ 之间的数，找出我们想要的答案。

在因数分解中，当我们找到 $n$ 的一个因子后，我们只是简单的将其存储，然后继续找下一个因子。而在质因数分解中，当我们找到 $n$ 的一个因子后，我们需要令 $n$ 不断除以该因子，直到 $n$ 不在包含该因子。

下面以 $12$ 为例进行因数分解和质因数分解的演示。

::: tabs

@tab 因数分解

枚举 $i$，$i \in [2,\sqrt{12}]$：
$$
\begin{align*}
i &= 2: & 12 \bmod 2 &= 0, \text{存储} \ 2,& 
\frac{12}{2} = 6 \neq 2, \text{存储} \ 6。 \\
i &= 3: & 12 \bmod 3 &= 0, \text{存储} \ 3, &
\frac{12}{3} = 4 \neq 3, \text{存储} \ 4 。
\end{align*}
$$
得到 $n$ 的因子有 $2,6,3,4$。

@tab 质因数分解

枚举 $i$，$i \in[2,\sqrt{12}]$：

$i=2$：$12 \bmod 2=0$，存储 $2$，并令 $12$ 不断除以 $2$，直至除尽：

- $12 \bmod 2 = 0 \Rightarrow 12 \div 2=6$；
- $6 \bmod 2=0 \Rightarrow 6 \div 2=3$；
- $3 \bmod 2=1 \neq 0$，停止。共除了 $2$ 次，记录质因子 $2$ 的指数为 $2$。

$i=3$：$3 \bmod 3=0$，存储 $3$，并令 $3$ 不断除以 $3$，直至除尽：

- $3 \bmod 3=0 \Rightarrow 3 \div 3=1$；
- $1 \bmod 3=1 \neq 0$，停止。共除了 $1$ 次，记录质因子 $3$ 的指数为 $1$。

得到 $n$ 的质因子有 $2,3$。

:::



在质因数分解的过程中，能被 $n$ 整除的 $i$，一定都是质数。

:::tip 证明

假如 $i$ 是一个合数，那么它一定可以分解成多个质因子相乘的形式，这多个质因子同时也是 $n$ 的质因子且比 $i$ 要小。但根据我们的步骤，比 $i$ 小的数在此之前的循环过程中已经被除尽了，所以 $i$ 不可能是合数，只可能是质数。

:::

此外，在枚举结束后，我们还需要对**剩余的 $n$** （除尽质因子后的 $n$）作判断。如果剩余的 $n$ 大于 $1$，则**剩余的 $n$ **也是**原来的 $n$** 的一个质因子，且指数为 $1$。

:::tip 说明

**原来的 $n$** 中最多可能包含一个大于 $\sqrt{n}$ 的质因子，且该质因子的指数最多为 $1$：

- 如果不止包含一个，则它们相乘的结果为大于 $n$；
- 如果指数大于 $1$，同理。

在我们枚举 $2\sim \sqrt{n}$ 的过程中，该质因子不会被除尽，就会被遗留下来。所以如果**剩余的数**大于 $1$，那么它就是那个大于 $\sqrt{n}$ 的质因子了。

:::

:::code-tabs

@tab C++

```cpp
const int N = 1e5 + 10;
int p[N]; // p 数组用来存储 n 的质因子
int a[N];	// a 数组用来存储 n 的质因子的指数。
void work(int n){
    int cnt = 0; // cnt 记录质因子的个数, p[cnt] 表示 n 的第 cnt 个质因子
    for(int i = 2 ; i * i <= n ; i ++)
        if(n % i == 0){ 
          	// 这里的 i 一定是 n 的质因子
            p[++ cnt] = i; // 将 i 存入 p 数组中
            while(n % i == 0) {
              	n /= i;  // 利用循环将 n 的质因子 i 除尽
              	a[cnt] ++ ; // 记录除了多少次,除的次数 = 质因子的指数
            }
        }
    if(n > 1) p[++ cnt] = n , a[cnt] = 1; // 枚举结束后，如果 n > 1，则说明剩下的 n 也为原来的 n 的一个质因子，指数为 1
		for(int i = 1 ; i <= cnt ; i ++) cout << p[i] << " " << a[i] << '\n';
}
```

:::

> 运行举例说明：
>
> - `work(7)` 返回的结果为：
>
> ```tex
> 7 1
> ```
>
> - `work(12)` 返回的结果为：
>
> ```tex
> 2 2
> 3 1
> ```
>
> - `work(30)` 返回的结果为：
>
> ```tex
> 2 1
> 3 1
> 5 1
> ```

### 二、求 $n$ 的约数的个数（**约数个数定理**）



:::info 简介

约数（因数）个数定理是一个关于正整数的数学定理，它声称：对于任意正整数 $n$，它的约数个数等于它分解质因数后每个质因子的指数加 $1$ 之积。

:::

举个例子，如果我们要计算 $12$ 的约数个数，我们可以将 $12$ 分解质因数：
$$
12 = 2^2 3^1
$$
然后，对于每个质因子，我们将它的指数加 $1$ 并相乘，得到：
$$
(2+1)\times(1+1) = 6
$$
因此，$12$ 的约数个数为 $36$。

具体地，如果 $n$ 的质因数分解式为：
$$
n=p_{1}^{a_{1}} \times p_{2}^{a_{2}}\times \cdots \times p_{k}^{a_{k}}
$$
那么 $n$ 的约数个数就为：
$$
\prod_{i=1}^{k} (a_{i}+1)=\left(a_{1}+1\right)\left(a_{2}+1\right) \cdots\left(a_{k}+1\right)
$$
至于原因，我们可以简单地用乘法原理来解释。

:::tip 乘法原理

做一件事，完成它需要分成 $n$ 个步骤，做第一步有 $m_1$ 种不同的方法，做第二步有 $m_2$ 种不同的方法，$\cdots$，做第 $n$ 步有 $m_n$ 种不同的方法，那么完成这件事共有 $m_1\times m_2 \times \cdots \times m_n$ 种不同的方法。

$n$ 可以分解质因数为 $p_{1}^{a_{1}} \times p_{2}^{a_{2}}\times \cdots \times p_{k}^{a_{k}}$，其中：

+ $p_1^{a_1}$ 的约数有 $p_1^{0},p_1^{1},\cdots,p_1^{a_1}$，共 $(a_1+1)$ 个；
+ $p_2^{a_2}$ 的约数有 $p_2^0,p_2^1,\cdots, p_2^{a_2}$，共 $(a_2 + 1)$ 个；
+ $\cdots$
+ $p_k^{a_k}$ 的约数有 $p_k^{0},p_k^1,\cdots ,p_k^{a_k}$，共 $(a_k+1)$ 个。

根据乘法原理可得 $n$ 的约数个数为 $\prod_{i=1}^{k} (a_{i}+1)=\left(a_{1}+1\right)\left(a_{2}+1\right) \cdots\left(a_{k}+1\right)$。

:::

::: code-tabs

@tab C++

```cpp
void work(int n){
    int ans = 1; // 记录 n 的约数个数。初始化为 1(乘法)
    for(int i = 2 ; i * i <= n ; i ++)
        if(n % i == 0){ 
          	int cnt = 0;
            while(n % i == 0) {
              	n /= i;  
              	cnt ++; // 记录质因数 i 的指数
            }
         		ans *= (cnt + 1);
        }
    if(n > 1) ans *= (1 + 1);
  	cout << ans << '\n';
}
```

:::

> 运行举例说明：
>
> - `work(4)` 返回的结果为：
>
> ```tex
> 3
> ```
>
> - `work(10)` 返回的结果为：
>
> ```tex
> 4
> ```
>
> - `work(12)` 返回的结果为：
>
> ```tex
> 6
> ```

### 三、求 $n$ 的所有约数的和（**约数和定理**）

---

:::info 简介

约数（因数）和定理是一个关于正整数的数学定理，它声称：对于任意正整数 $n$，它的约数之和等于它分解质因数后每个质因子的所有次幂之和的乘积。

:::

举个例子，如果我们要计算 $12$ 的约数之和，我们可以将 $12$ 分解质因数：
$$
12 = 2^2 3^1
$$
然后，对于每个质因子，我们将它的约数相加并相乘，得到：
$$
(2^0 + 2^1 + 2^2)\times (3^0 + 3^1)=  7\times 4 = 28
$$
因此，$12$ 的约数之和为 $28$。

具体地，如果 $n$ 的质因数分解式为：
$$
n=p_{1}^{a_{1}} \times p_{2}^{a_{2}}\times \cdots \times p_{k}^{a_{k}}
$$
那么 $n$ 的约数之和就为：
$$
(p_1^0+p_1^1+\cdots +p_1^{a_1})(p_2^0+p_2^1+...+p_2^{a2})\cdots(p_k^0+p_k^1+\cdots + p_k^{a_k})
$$
至于原因，我们同样可以用乘法原理证明。

仔细观察不难发现：

::: left

$p_1^0 + p_1^1 + \cdots +p_1^{a_1}$

$p_2^0+p_2^1+...+p_2^{a2}$

$\cdots$

$p_k^0+p_k^1+\cdots + p_k^{a_k}$

:::

均是等比数列。因此，我们可以套用等比数列求和公式，进一步得到：
$$
\prod_{i=1}^{k} \dfrac{p_{i}^{a_{i}+1}-1}{p_{i}-1} = \dfrac{p_1^{a_1+1}-1}{p_1-1}\times \dfrac{p_2^{a_2+1}-1}{p_2-1}\times \cdots \times \dfrac{p_k^{a_k + 1} - 1}{p_k - 1}
$$

##### 核心代码实现在题目中给出。



