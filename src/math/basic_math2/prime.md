---
title: 质数
icon: circle-info
pageInfo: [ReadingTime, Word]

---


::: info 简介

质数，又称素数，是一种特殊的自然数，它只能被 $1$ 和本身整除。

质数的定义可以被表述为：除了 $1$ 和本身以外，没有其他的因数。

举个例子，$2$ 是一个质数，因为它只能被 $1$ 和 $2$ (本身)整除；$4$ 不是一个质数，因为它能被 $2$ 整除。

在日常生活中，我们常见的质数有 $3,5,7,11,13$ 等等。由于质数是自然数中唯一无法被其他数整除的数，因此质数的性质在很多数学理论中都有着重要的作用。

:::

## 质数的判定

判定一个数是否是质数的方法很多，以下将介绍两种较为简单的方法：

1. 枚举法。
2. 因数分解法。

### 一、枚举法

---

我们知道，对于一个正整数 $n$，它的因数必然是小于等于它本身的。于是，我们可以从 $2$ 开始逐个枚举小于 $n$ 的所有数，判断其中是否存在 $n$ 的因数。如果找到一个 $n$ 的因数，则该数不是质数；如果枚举完后都没有找到因数，则 $n$ 是质数。

::: code-tabs

@tab C++

```cpp
bool is_Prime(int n){
  if(n <= 1) return false;  // 规定：0 和 1 不是质数
  for(int i = 2 ; i < n ; i ++)   // 枚举 [2 , n) 
    if(n % i == 0) return false;  // 如果 i 可以被 n 整除，说明 i 是 n 的因数，即 n 不是质数
  return true; // 如果没有找到因数，则 n 是质数
}
```

:::

> 运行举例说明：
>
> 1. `is_prime(7)` 返回的结果为 `true`，说明 $7$ 是一个质数；
> 2. `is_Prime(10)` 返回的结果为 `false`，说明 $10$ 不是一个质数；
> 3. `is_Prime(13)` 返回的结果为 `true`，说明 $13$ 是一个质数。

在判断 $n$ 是否是质数的同时，用 `vector` 存储下 $n$ 的因数（不包含 $1$ 和 $n$）

:::code-tabs

@tab C++

```cpp
void work(int n){
  vector<int>vec;
  for(int i = 2 ; i < n ; i ++)
    if(n % i == 0)  
  		vec.push_back(i); // 将 i 存入 vec 中
  if(vec.size() == 0 || n == 1) cout << n << " 是质数\n";
  else {
    cout << n << " 不是质数\n";
  	cout << n << " 的因子有: ";
    for(auto i : vec) cout << i << " "; // 输出 n 的因数
  }
}
```

:::

> 运行举例说明：
>
> - `work(7)` 返回的结果为：
>
> ```tex
> 7 是质数
> ```
>
> - `work(10)` 返回的结果为：
>
> ```tex
>10 不是质数
> 10 的因子有: 2 5
> ```

枚举法的编码量小，思路简单，不易出错，但时间复杂度为 $O(n)$，算法效率低。因此，在绝对多数情况下，我们不会使用该方法来判断一个数是否为质数。

### 二、因数分解法

---

因数分解法的本质也是通过枚举，找寻 $n$ 的因数，只不过它的枚举范围不再是 $[2,n)$，而是 $[2,\sqrt(n)]$，即从 $2$ 开始逐个枚举 $\sqrt{n}$ 之间的所有数，判断其中是否存在 $n$ 的因数。

:::details 为什么枚举范围能够缩小至 [2,√n] 呢？

首先我们要知道，**因数都是成对存在的**。比如 $10$，你找到了一个因数 $2$，则一定有个因数 $5$，因为 $\dfrac{10}{2} = 5$。

对于一个合数 $n$，我们设它的一对因数为 $a,b(n = a\times b)$。那么，在 $a,b$ 中，**必然有一个值小于等于** $\sqrt{n}$，**一个值大于等于** $\sqrt{n}$。

这是因为：

- 如果 $a,b$ 都小于 $\sqrt{n}$，则 $a\times b < \sqrt{n}\times \sqrt{n} = n$；
- 如果 $a,b$ 都大于 $\sqrt{n}$，则 $a\times b > \sqrt{n}\times \sqrt{n} = n$。

根据以上讨论的两点：

1. **因数都是成对存在的；**
2. **在一对因数中，必然有一个值小于等于 $\sqrt{n}$，一个只大于等于 $\sqrt{n}$。**

因此，如果在 $\sqrt{n}$ 之前都找不到 $n$ 的因数的话，$\sqrt{n}$ 之后也就不会有因数了（即 $n$ 是一个质数）。

:::

::: code-tabs

@tab C++

```cpp
bool is_Prime(int n){
  if(n <= 1) return false;  // 规定：0 和 1 不是质数
  for(int i = 2 ; i * i <= n ; i ++)   // 枚举 [2 , √n) 
    if(n % i == 0) return false;  // 如果 i 可以被 n 整除，说明 i 是 n 的因数，即 n 不是质数
  return true; // 如果没有找到因数，则 n 是质数
}
```

:::

> 运行举例说明：
>
> - `is_prime(7)` 返回的结果为 `true`，说明 $7$ 是一个质数；
> - `is_Prime(10)` 返回的结果为 `false`，说明 $10$ 不是一个质数；
> - `is_Prime(13)` 返回的结果为 `true`，说明 $13$ 是一个质数。

我们也可以在判断 $n$ 是否是质数的同时，用 `vector` 存储下 $n$ 的因数（不包含 $1$ 和 $n$）。

::: code-tabs

@tab C++

```cpp
void work(int n){
  vector<int>vec;
  for(int i = 2 ; i * i <= n ; i ++)
    if(n % i == 0){
      vec.push_back(i);
      // 如果 i 是 n 的因数，则 n/i 也是 n 的因数
      // 但由于 n/i 可能等于 i，所以为了避免相同的数被重复存储，我们需要判断 n/i 和 i 是否相同
      if(n / i != i)  vec.push_back(n / i);
    }
  if(vec.size() == 0 || n != 1) cout << n << " 是质数\n";
  else {
    cout << n << " 不是质数\n";
  	cout << n << " 的因子有: ";
    for(auto i : vec) cout << i << " "; // 输出 n 的因数
  }
}
```

:::

> 运行举例说明：
>
> - `work(7)` 返回的结果为：
>
> ```tex
> 7 是质数
> ```
>
> - `work(12)` 返回的结果为：
>
> ```tex
>12 不是质数
> 12 的因子有: 2 6 3 4
> ```

因数分解法的时间复杂度相对较低，为 $O(\sqrt{n})$，在绝大多数情况下都能满足要求。若需要处理更大的数据，我们可以使用更高效的算法，如**欧拉筛法**、 **Miller-Rabin** 算法等。
